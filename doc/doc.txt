Projet pluri-disciplinaire - IUT Paris Descartes
================================================


Architecture du projet :
========================

/
|--- bin/              # binaires et DLL
|    |--- data/
|         |--- images/ # les images utilisées par l'application
|         |--- map/    # les cartes des zones de jeu
|         |--- music/  # les musiques
|         |--- postfx/ # les postfx (scripts d'effet graphique)
|         |--- sound/  # les sons
|         |--- xml/    # des configurations en XML
|
|--- doc/              # les éléments de documentation
|
|--- src/              # sources du projet
|    |--- tinyxml/     # la bibliothèque TinyXML
|
|--- test/             # tests unitaires, bac à sable
|
|--- utils/            # des scripts en Python
|    |--- editor/      # l'éditeur de carte (Python)
|
|--- Makefile


Détails des composants :
========================

Game
----

Game est la classe centrale du jeu, c'est un singleton (un seul objet possible).
Game n'est pas le seul singleton du jeu, je rappelle brièvement comment on
récupère une référence sur un objet singleton :
NomClasse& ma_reference = NomClasse::GetInstance();

La méthode principale de Game est Run(), c'est la boucle principale du jeu.
La boucle de jeu se déroule en 3 étapes :
1) POLLING, c'est la récupération des évènements.
La récupération est non bloquante, c'est à dire que s'il y a un évènement, on le
traite, s'il n'y en a pas, tant pis on ne fait rien, on regardera au prochain
tour de boucle.
2) UPDATE, c'est la mise à jour de tout ce qu'il y a l'écran (par exemple,
les déplacements).
3) RENDER, c'est le rendu, l'affichage des objets.

Un tour de boucle constitue une frame.
La constante APP_FPS (APPlication Frame Per Second) définit à 60 le nombre
maximum de frames par seconde (ce nombre est seulement un plafond, on ne peut
pas garantir que la machine pourra atteindre ce taux).

La séquence Polling / Update / Render peut être très différente selon l'état
du jeu. Par exemple, si on ouvre l'inventaire, la gestion des flèches doit
naviguer dans l'inventaire, et non diriger le joueur.

Pour modifier le comportement de la boucle de jeu, Game dispose de 3 pointeurs
de méthodes :
on_event_meth_, update_meth_, et render_meth_
qui correspondent chacun à une partie des 3 étapes.
Ces pointeurs de méthodes contiennent l'adresse des méthodes à exécuter à chaque
tour de boucle.
L'intérêt est de ne pas avoir plein de if dans le code de la boucle principale,
on découpe chaque partie du code dans une méthode particulière.

L'énumération Game::Mode définit les modes de jeu, c'est à dire les combinaisons
de ces 3 pointeurs de méthodes.
Ainsi, pour basculer en mode Inventaire, un simple
SetMode(INVENTORY);
suffit (les pointeurs de méthodes seront mis à jour).

Les éléments du jeu sont encapsulés dans un objet ZoneContainer.


ZoneContainer
-------------

Le jeu est divisé en zones, chaque zone fait la taille de l'écran.
ZoneContainer contient une matrice de zones, ainsi qu'un pointeur sur la zone
courante (l'attribut active_zone_).
Quand on doit changer de zone en passant par une frontière (haut, bas, gauche,
droite), on utilise la méthode :
ChangeZone(Direction)

Il est également possible d'aller dans n'importe quelle zone directement avec
la méthode SetActiveZone (on passe les coordonnées de la zone cible dans la
matrice de ZoneContainer).

ZoneContainer s'occupe de vérifier si le changement de zone est autorisé, fait
un effet de scrolling et change la zone courante.
Le joueur est supprimé de l'ancienne zone et inséré dans la nouvelle, car chaque
zone contient la liste de ses entités.

Les groupes de zones d'un ZoneContainer sont déjà prédéfinis dans des fichiers
XML (dans data/map/), et à chaque fichier XML correspond un identifiant
(énumération ZoneContainer::MapName)

ZoneContainer::Load permet de charger un de ces groupes de zones en passant une
des valeurs MapName en paramètre.


Zone
----

Zone est un écran de jeu. Chaque zone contient sa liste d'entités (entities_),
sa liste d'objets (items_) et ses téléporteurs (teleporters_).
Avant d'utiliser une zone, il faut la construire avec la méthode Load().
Cette méthode prend en paramètre un nœud XML de type TiXmlHandle.
Ce nœud doit correspondre à une entrée <zone> dans le fichier XML d'une carte,
et à partir des indications qui s'y trouvent, constituer le décor, insérer les
entités et les téléporteurs, etc.
Le décor est représenté par une suite de numéro (des id), chacun d'entre eux est
associé à petit carré de la carte, appelé "Tile".
Cet id permet de déterminer l'image de la tile, si on a le droit de marcher
dessus, etc.


Tileset
-------

Tileset est un singleton dédié à la gestion des id des tiles.
C'est cette classe qui permet, à partir d'un id, de définir tous les attributs
d'une tile.
Les attributs des tiles ne sont pas codés en dur dans Tileset, ils se trouvent
dans le fichier data/xml/tiles.xml.


MediaManager
------------

Encore une classe singleton. Le MediaManager sert à contenir tous les médias du
jeu, c'est à dire les images, les sons, les musiques, etc.
Tous les contenus sont identifiés par une chaîne de caractères, qui correspond
au nom de la ressource sans son extension.
Ainsi, l'image pingouin.png est identifiée par "pingouin", le son boom.wav par
"boom", etc.
Quelques fonctions inlines permettent de raccourcir la syntaxe, qui est un peu
longue. Ainsi,
sf::Image& img = MediaManager::GetInstance().GetImage("pingouin");
peut être remplacé par :
sf::Image& img = GET_IMG("pingouin");

Les entités
-----------

Les entités concernent les classes Entity, Player, Enemy, StaticItem.
Entity est la classe de base de toutes les entités, qui elle même hérite de
sf::Sprite.
Une entité est mise à jour avec Update.
Comme une entité est un sprite, on peut directement l'afficher, la déplacer,
obtenir sa position, etc. (voir les méthodes de sf::Sprite dans la documentation
SFML).


Les animations sur les entités
------------------------------

Par défaut, les entités ne sont pas animées.
Les animations sont fournies par les classes Animation et Animated.
Animation est un tableau de rectangles, qui définissent quelle sous-partie
d'une image il faut utiliser.
Les animations sont stockées dans MediaManager.
Animated est un timer lié à un objet Animation, il fait défiler les sous-parties
de l'image.
Pour avoir une entité animée, il faut faire de l'héritage multiple.
Ainsi, Player hérite de Entity ET de Animated.


ControlPanel
------------

Cette classe est un singleton et définit l'interface visuel de l'utilisateur.
ControlPanel sert donc à afficher toutes les informations à l'écran, comme le
nombre de vie, l'argent, etc.


Music
-----

La SFML ne gère par certains formats musicaux, comme le .xm ou le .mod.
Cette classe permet de charger et de jouer des fichiers de ces formats, grâce
à la bibliothèque DUMB.


Misc
----

Ce composant ne contient pas de classe, juste quelques fonctions pratiques qui
ne sont pas directement liées au projet.
str_sprintf permet notamment de construire des std::string avec la syntaxe de
la vénérable fonction printf :
std::string ma_string = str_sprintf("J'ai %d ans", 42);


Format d'une carte XML
======================

Les cartes sont encodés en XML.
Voici un exemple :

<?xml version="1.0" encoding="utf-8" ?>
<map width="2" height="2">
	<zone>
		<tiles>...</tiles>
		<entities>
			<entity name="blah" x="2" y="5" />
			...
		</entities>
		<teleporters>
			<tp x="9" y="1" container="1" zone_x="0" zone_y="0" tile_x="8" tile_y="4" />
		</teleporters>
	</zone>
	<zone>
		...
	</zone>
</map>

"map" est l'élément racine. Les attributs "width" et "height" indiquent combien
il y a de zones en largeur et en hauteur.
Chaque zone correspond à une entrée <zone> (il doit y avoir width * height
entrées <zone>).
Dans chaque zone, on trouve :

* les tiles : tous les id à la suite en plein texte, entre les tags <tiles> et
</tiles>.
	
* les entités : une entrée <entity /> par entité, entre les tags <entities> et
</entities>.
Les attributs de <entity /> :
	- name: l'identifiant
	- x: la position x en tiles
	- y: la position y en tiles

S'il n'y a pas d'entités, l'entrée <entities> est optionnelle.

* les téléporteurs : une entrée <tp /> par téléporteur, entre les tags
<teleporters> et </teleporters>
Les attribut de <tp /> :
Le téléporteur est localisé dans la zone avec :
	- x: position x en tiles
	- y: position y en tiles
La destination est localisée avec :
	- container: valeur énumérée ZoneContainer::MapName (identifie le conteneur
	de zones cible)
	- zone_x: position x de la zone cible
	- zone_y: position y de la zone cible
	- tile_x: position x en tiles dans la zone cible
	- tile_y: position y en tiles dans la zone cible

S'il n'y a pas de téléporteurs, l'entrée <teleporters> est optionnelle.


Format des animations
=====================

Les animations sont définis dans data/xml/animations.xml
Exemple :

<?xml version="1.0" encoding="utf-8" ?>
<animations>
	<anim name="player_walk_up" width="32" height="48" count="8" delay="0.125" x_offset="32" y_offset="0" />
	...
</animations>

Attributs de <anim />
	- name: identifiant de l'animation
	- width: largeur d'une frame
	- height: hauteur d'une frame
	- count: nombre de frames
	- delay: délai entre chaque frame
	- x_offset: décalage de l'origine en x
	- y_offset: décalage de l'origine en y

Une entrée "anim" par animation.
Les animations sont construites et stockées dans MediaManager.

