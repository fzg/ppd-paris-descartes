Projet pluri-disciplinaire - IUT Paris Descartes
================================================


Architecture du projet :
========================

/                 # tous les fichiers sources + Makefile
|--- data/
|    |--- images/ # les images utilisées par l'application
|    |--- map/    # les cartes des zones de jeu
|    |--- music/  # les musiques
|    |--- postfx/ # les postfx (scripts d'effet graphique)
|    |--- sound/  # les sons
|	 |--- xml/    # des configurations en XML
|
|--- doc/         # les éléments de documentation
|
|--- tinyxml/     # la bibliothèque TinyXML
|
|--- utils/       # des scripts en Python
     |--- editor/ # l'éditeur de carte (Python)


Détails des composants :
========================

Game
----

Game est la classe centrale du jeu, c'est un singleton (un seul objet possible).
Game n'est pas le seul singleton du jeu, je rappelle brièvement comment on
récupère une référence sur un objet singleton :
NomClasse& ma_reference = NomClasse::GetInstance();

Le jeu est divisé en zones, chaque zone fait la taille de l'écran.
Game contient une matrice de zones, ainsi qu'un pointeur sur la zone courante.
(l'attribut active_zone_).
Quand on doit changer de zone, on passe par Game avec la méthode :
ChangeZone(Direction)

Game s'occupe de vérifier si le changement de zone est autorisé, fait un effet
de scrolling et change la zone courante.
Le joueur est supprimé de l'ancienne zone et inséré dans la nouvelle.

La méthode principale de Game est Run(), c'est la boucle principale du jeu.
La boucle de jeu se déroule en 3 étapes :
1) POLLING, c'est la récupération des évènements.
La récupération est non bloquante, c'est à dire que s'il y a un évènement, on le
traite, s'il n'y en a pas, tant pis on ne fait rien, on regardera au prochain
tour de boucle.
2) UPDATE, c'est la mise à jour de tout ce qu'il y a l'écran (par exemple,
les déplacements).
3) RENDER, c'est le rendu, l'affichage des objets.

Un tour de boucle constitue une frame.
La constante APP_FPS (APPlication Frame Per Second) définit à 60 le nombre
maximum de frames par seconde.

La séquence Polling / Update / Render peut être très différente selon l'état
du jeu. Par exemple, si on ouvre l'inventaire, la gestion des flèches doit
naviguer dans l'inventaire, et non diriger le joueur.

Pour modifier le comportement de la boucle de jeu, Game dispose de 3 pointeurs
de méthodes :
on_event_meth_, update_meth_, et show_meth
qui correspondent chacun à une partie des 3 étapes.
Ces pointeurs de méthodes contiennent l'adresse des méthodes à exécuter à chaque
tour de boucle.
L'intérêt est de ne pas avoir plein de if dans le code de la boucle principale,
on découpe chaque partie du code dans une méthode particulière.

Zone
----

Zone est un écran de jeu. Chaque zone contient sa liste d'entités (entities_) et
sa liste d'objets (items_).
Avant d'utiliser une zone, il faut la construire avec la méthode Load().
Cette méthode prend en paramètre un fichier carte écrit en XML (contenu dans
data/map/), et à partir des indications qui s'y trouvent, constituer le décor de
la carte et insérer les entités.
Le décor est représenté par une suite de numéro (des id), chacun d'entre eux est
associé à petit carré de la carte, appelé "Tile".
Cet id permet de déterminer l'image de la tile, si on a le droit de marcher
dessus, etc.

Tileset
-------

Tileset est un singleton dédié à la gestion des id des tiles.
C'est cette classe qui permet, à partir d'un id, de définir tous les attributs
d'une tile.
Les attributs des tiles ne sont pas codés en dur dans Tileset, ils se trouvent
dans le fichier data/xml/tiles.xml.

MediaManager
------------

Encore une classe singleton. Le MediaManager sert à contenir tous les médias du
jeu, c'est à dire les images, les sons, les musiques, etc.
Tous les contenus sont identifiés par une chaîne de caractères, qui correspond
au nom de la ressource sans son extension.
Ainsi, l'image pingouin.png est identifiée par "pingouin", le son boom.wav par
"boom", etc.
Quelques fonctions inlines permettent de raccourcir la syntaxe, qui est un peu
longue. Ainsi,
sf::Image& img = MediaManager::GetInstance().GetImage("pingouin");
peut être remplacé par :
sf::Image& img = GET_IMG("pingouin");

Les entités
-----------

Les entités concernent les classes Entity, Player, Enemy, StaticItem.
Entity est la classe de base de toutes les entités, qui elle même hérite de
sf::Sprite.
Une entité est mise à jour avec Update.
Comme une entité est un sprite, on peut directement l'afficher, la déplacer,
obtenir sa position, etc. (voir les méthodes de sf::Sprite dans la documentation
SFLM)

Les animations sur les entités
------------------------------

Par défaut, les entités ne sont pas animées.
Les animations sont fournies par les classes Animation et Animated.
Animation est un tableau de rectangles, qui définissent quelle sous-partie
d'une image il faut utiliser.
Les animations sont stockées dans MediaManager.
Animated est un timer lié à un objet Animation, il fait défiler les sous-parties
de l'image.
Pour avoir une entité animée, il faut faire de l'héritage multiple.
Ainsi, Player hérite de Entity ET de Animated.


ControlPanel
------------

Cette classe est un singleton et définit l'interface visuel de l'utilisateur.
ControlPanel sert donc à afficher toutes les informations à l'écran, comme le
nombre de vie, l'argent, etc.

Music
-----

La SFML ne gère par certains formats musicaux, comme le .xm ou le .mod.
Cette classe permet de charger et de jouer des fichiers de ces formats, grâce
à la bibliothèque DUMB.

Misc
----

Ce composant ne contient pas de classe, juste quelques fonctions pratiques qui
ne sont pas directement liées au projet.
str_sprintf permet notamment de construire des std::string avec la syntaxe de
la vénérable fonction printf :
std::string ma_string = str_sprintf("J'ai %d ans", 42);

